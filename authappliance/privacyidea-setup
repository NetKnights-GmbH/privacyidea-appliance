#!/usr/bin/python
# -*- coding: utf-8 -*-
#  copyright 2014 Cornelius KÃ¶lbel
#  License:  AGPLv3
#  contact:  http://www.privacyidea.org
#
# This code is free software; you can redistribute it and/or
# License as published by the Free Software Foundation; either
# version 3 of the License, or any later version.
#
# This code is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU AFFERO GENERAL PUBLIC LICENSE for more details.
#
# You should have received a copy of the GNU Affero General Public
# License along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
text dialog based setup tool to configure the privacyIDEA basics.
"""

import locale
import argparse
import sys
import time
from dialog import Dialog
from authappliance.lib.appliance import (Backup,
                           FreeRADIUSConfig,
                           PrivacyIDEAConfig,
                           WebserverConfig, OSConfig, MySQLConfig,
                           DEFAULT_CONFIG)
from privacyidea.lib.auth import (create_db_admin, get_db_admins,
                                  delete_db_admin)
from privacyidea.models import Admin
from privacyidea.app import create_app
from netaddr import IPAddress
from paramiko.client import SSHClient
from paramiko import SSHException, AutoAddPolicy, SFTPClient, Transport
from subprocess import Popen, PIPE, call
import random
import os
from tempfile import NamedTemporaryFile


DESCRIPTION = __doc__
VERSION = "2.0"


class OSMenu(object):

    def __init__(self, app, dialog):
        self.app = app
        self.d = dialog
        self.os = OSConfig()

    def menu(self):
        bt = "Operating System"
        while 1:
            code, tags = self.d.menu("Operating System",
                                     choices=[("system information", ""),
                                              ("network configuration", ""),
                                              ("set password of piadmin", ""),
                                              ("reboot system", ""),
                                              ("shutdown system", "")
                                             ],
                                     backtitle=bt)

            if code == self.d.DIALOG_OK:
                if tags.startswith("reboot"):
                    self.os.reboot(echo=True)
                    self.d.msgbox("Rebooting the system. Standby and wait for "
                                  "the system come up again.")
                elif tags.startswith("shutdown"):
                    self.os.halt(echo=True)
                    self.d.msgbox("Shutting down the system.")
                elif tags.startswith("Set password"):
                    self.os.set_password("piadmin")
                elif tags.startswith("system information"):
                    self.system_information()
                elif tags.startswith("network configuration"):
                    self.network_configuration()
            else:
                break

    def system_information(self):
        diskspace = self.os.get_diskfree()
        network = self.os.get_network()
        self.d.scrollbox("""
Free Disk Space
===============

%s

Network
=======

IP address: %s
Netmask   : %s
Nameserver: %s
Gateway   : %s
""" % (diskspace, network.get("address"),
       network.get("netmask"),
       network.get("dns-nameservers"),
       network.get("gateway")), width=60, height=20)

    def network_configuration(self):
        bt = "Network configuration"
        network = self.os.get_network()
        code, r = self.d.inputbox("Please enter the IP address",
                                  width=60,
                                  init=network.get("address"))
        if code is not self.d.DIALOG_OK:
            return
        network["address"] = r
        code, r = self.d.inputbox("Please enter the Netmask",
                                  width=60,
                                  init=network.get("netmask"))
        if code is not self.d.DIALOG_OK:
            return
        network["netmask"] = r
        code, r = self.d.inputbox("Please enter the Gateway",
                                  width=60,
                                  init=network.get("gateway"))
        if code is not self.d.DIALOG_OK:
            return
        network["gateway"] = r
        code, r = self.d.inputbox("Please enter the Nameserver",
                                  width=60,
                                  init=network.get("dns-nameservers"))
        if code is not self.d.DIALOG_OK:
            return
        network["dns-nameservers"] = r
        code = self.d.yesno("Are these values ok - and shall I activate the "
                            "new network configuration? \n"
                            "%s/%s\n"
                            "Gateway: %s\n"
                            "Nameserver: %s" %
                            (network.get("address"), network.get("netmask"),
                             network.get("gateway"), network.get(
                                "dns-nameservers")),
                            width=60)
        if code == self.d.DIALOG_OK:
            self.os.set_network(network)


class WebserverMenu(object):

    def __init__(self, app, dialog):
        self.app = app
        self.os = OSConfig()
        self.d = dialog
        self.webserver = WebserverConfig()

    def menu(self):
        bt = "Webservice configuration"
        while 1:
            # TODO: Add more webserver tasks
            #code, tags = self.d.menu("Configure Webserver",
            #                         choices=[("enable or disable
            ## webserver", ""),
            #                                  ("webservices", ""),
            #                                  ("create new certificates", ""),
            #                                  ("restart services", "")
            #                             ],
            #                         backtitle=bt)
            code, tags = self.d.menu("Configure Webserver",
                                     choices=[("restart services", ""),
                                              ("create new certificates", "")
                                              ],
                                     backtitle=bt)
            if code == self.d.DIALOG_OK:
                if tags.startswith("enable"):
                    self.enable()
                elif tags == "create new certificates":
                    self.certificate()
                elif tags.startswith("webservices"):
                    self.services()
                elif tags.startswith("restart"):
                    self.restart()
            else:
                break

    def certificate(self):
        code = self.d.yesno("This will overwrite the existing "
                            "certificate. Create new?",
                            backtitle="Create webserver certificate",
                            defaultno=1)
        if code == self.d.DIALOG_OK:
            self.WebserverConfig.create_certificates()
            self.data_changed = True


    def services(self):
        webservices = self.WebserverConfig.get_webservices()
        code, tags = self.d.checklist("Enable nginx webservices. Only enable "
                                      "'privacyidea' unless you exactly know, "
                                      "what you are doing!",
                                      choices=webservices,
                                      backtitle="Enable webserives")
        if code == self.d.DIALOG_OK:
            self.WebserverConfig.enable_webservice(tags)
            self.data_changed = True

    def restart(self):
        code = self.d.yesno("Do you want to restart the services for the "
                            "changes to take effect?")
        if code == self.d.DIALOG_OK:
            self.os.restart()
            self.data_changed = False

    def enable(self):
        nginx, uwsgi = self.WebserverConfig.is_active()

        code, tags = self.d.radiolist("enable or disable the webservice",
                                      choices=[("enable",
                                                "privacyIDEA "
                                                "will start automatically "
                                                "at boot time",
                                                int(nginx and uwsgi)),
                                               ("disable",
                                                "privacyIDEA "
                                                "will not start automatically.",
                                                int(not(nginx and uwsgi)))],
                                      width=70,
                                      backtitle="Enable or disable webservice")
        if code == self.d.DIALOG_OK:
            if tags == "enable":
                self.WebserverConfig.enable()
                self.data_changed = True
            elif tags == "disable":
                self.WebserverConfig.disable()
                self.data_changed = True


class Peer(object):

    files = ["/etc/privacyidea/enckey", "/etc/privacyidea/pi.cfg",
             "/etc/privacyidea/logging.cfg",
             "/etc/privacyidea/private.pem", "/etc/privacyidea/public.pem"]

    def __init__(self, dialog, pConfig, dbConfig, remote_ip=None,
                 password=None, local_ip=None):
        self.remote_ip = remote_ip
        self.local_ip = local_ip
        self.password = password
        self.d = dialog
        self.pConfig = pConfig
        self.dbConfig = dbConfig
        self.ssh = SSHClient()
        self.os = OSConfig()
        self.info = ""
        self.file_local = ""
        self.file_remote = ""
        self.position_local = ""
        self.position_remote = ""


    def get_peer_data(self):
        bt = "Add another SQL Master"
        code, ip = self.d.inputbox(
            "Enter the IP Address of the other privacyIDEA server.",
            backtitle=bt)
        if code != self.d.DIALOG_OK:
            return False

        try:
            self.remote_ip = IPAddress(ip)
        except:
            self.d.msgbox("Invalid IP address")
            return False

        code, password = self.d.passwordbox(
            "Enter the root password of the other machine.",
            backtitle=bt)
        if code != self.d.DIALOG_OK:
            return False

        self.password = password

        code, local_ip = self.d.inputbox(
            "Enter the local IP Address of this machine, to which the remote "
            "server will connect.", backtitle=bt)
        if code != self.d.DIALOG_OK:
            return False

        try:
            self.local_ip = IPAddress(local_ip)
        except:
            self.d.msgbox("Invalid IP address")
            return False

        return True

    def add_info(self, new_info):
        self.info += new_info + "\n"
        self.d.infobox(self.info, height=20, width=60)

    def read_maintainer_password(self):
        f = open("/etc/mysql/debian.cnf")
        for line in f:
            if line.startswith("password ="):
                maintainer_password = line.split("=")[1].strip()
        f.close()
        return maintainer_password

    def stop_redundancy(self):
        self.info = ""
        self.add_info("Stopping local webserver")
        self.os.restart(service="apache2", action="stop")

        # To stop redundancy we remove
        # several fields from the my.cnf file.
        self.add_info("Removing config from my.cnf...")
        self.dbConfig.set("mysqld", "bind-address", "127.0.0.1")
        for setting in ["server-id", "auto_increment_increment",
                        "auto_increment_offset", "log_bin", "binlog_do_db"]:
            self.dbConfig.delete("mysqld", setting)

        # delete the replication user
        self.add_info("Dropping replicator user...")
        maintainer_password = self.read_maintainer_password()
        p = Popen(['mysql', '--user=debian-sys-maint',
                   '--password={0}'.format(maintainer_password)],
                   stdin=PIPE,
                   stdout=PIPE,
                   stderr=PIPE)
        output, err = p.communicate(input="drop user 'replicator'@'%';")
        r = p.returncode
        if r != 0:
            self.add_info("Error dropping replicator user: {0}".format(err))

        # stop the slave
        self.add_info("Stopping the slave...")
        p = Popen(['mysql', '--user=debian-sys-maint',
                   '--password={0}'.format(maintainer_password)],
                  stdin=PIPE,
                  stdout=PIPE,
                  stderr=PIPE)

        output, err = p.communicate(input="stop slave; reset slave;")
        r = p.returncode
        if r != 0:
            self.add_info("Error stopping slave: {0}".format(err))
        # restart mysql
        self.add_info("Restarting MySQL server...")
        self.dbConfig.restart()
        self.add_info("Starting local webserver...")
        self.os.restart(service="apache2", action="start")
        self.add_info("done.")
        self.d.scrollbox(self.info, height=20, width=60)

    def setup_redundancy(self):
        #
        # Copy files in /etc/privacyidea
        #
        self.info = ""
        self.add_info("copying files to remote server...")
        transport = Transport((str(self.remote_ip), 22))
        transport.connect(username="root", password=self.password)
        sftp = SFTPClient.from_transport(transport)
        for file in self.files:
            sftp.put(file, file)
        #
        # Setup my.cnf
        #
        self.add_info("Setup my.cnf on remote server...")
        self.dbConfig.set("mysqld", "server-id", 2)
        self.dbConfig.set("mysqld", "auto_increment_increment", 2)
        self.dbConfig.set("mysqld", "auto_increment_offset", 2)
        self.dbConfig.set("mysqld", "log_bin", "/var/log/mysql/mysql-bin.log")
        self.dbConfig.set("mysqld", "binlog_do_db", "pi")
        self.dbConfig.set("mysqld", "bind-address", "0.0.0.0")
        sftp.put("/etc/mysql/my.cnf", "/etc/mysql/my.cnf")
        sftp.close()
        transport.close()

        self.add_info("Setup my.cnf on local server...")
        self.dbConfig.set("mysqld", "server-id", 1)
        self.dbConfig.set("mysqld", "auto_increment_offset", 1)
        #
        # Restart services
        #
        self.add_info("Restarting local MySQL server...")
        self.dbConfig.restart()
        self.add_info("Restarting remote MySQL server...")
        self.ssh.connect(str(self.remote_ip), username="root",
                         password=self.password)
        stdin, stdout, stderr = self.ssh.exec_command("service mysql restart")
        if stderr:
            self.add_info(stderr.read())
        #
        # Configuring mysql
        #
        # Before configuring mysql we stop the webserver
        self.add_info("Stopping local webserver")
        self.os.restart(service="apache2", action="stop")
        self.add_info("Stopping remote webserver")
        stdin, stdout, stderr = self.ssh.exec_command("service apache2 stop")
        if stderr:
            self.add_info(stderr.read())


        self.add_info("Configuring MySQL on local server...")
        # We start at 40, since 39 is "'" which might lead to confusion.
        # Create a random password of random length
        replicator_password = "".join([random.choice(
            "01234567890abcdefghijklmnopqrstuvwxyzABZDEFGHIJKLMNOPQRSTUVWXYZ")
                                       for x in
                                       range(random.randrange(21,31))])

        # determine the password
        maintainer_password = self.read_maintainer_password()

        stdin, stdout, stderr = self.ssh.exec_command(
            "grep password /etc/mysql/debian.cnf | sort -u | cut -d'=' -f 2")
        err = stderr.read()
        output = stdout.read()
        if err:
            self.add_info("ERROR: {0}".format(err))
        else:
            maintainer_password2 = output.strip()

        #
        # dump it and copy it to the other server
        #
        self.add_info("Dumping and copying the existing database...")

        dumpfile = NamedTemporaryFile(mode="w", delete=False)
        p = Popen(["mysqldump", "--user=debian-sys-maint",
                   "--databases",  "--add-drop-database",
                   "--password={0}".format(maintainer_password), "pi"],
                  stdout=dumpfile, stderr=PIPE)
        output, err = p.communicate()
        r = p.wait()
        if r == 0:
            self.add_info("Saved SQL dump to {0}".format(dumpfile.name))
            # copy the file.name to the remote machine and run the file.
            self.add_info("Copying to remote server and creating remote "
                          "database. This may take a while...")
            transport = Transport((str(self.remote_ip), 22))
            transport.connect(username="root", password=self.password)
            sftp = SFTPClient.from_transport(transport)
            sftp.put(dumpfile.name, dumpfile.name)
            sftp.close()
            transport.close()
            # delete the file
            os.unlink(dumpfile.name)
            # run the file remotely
            # mysql -u root -p < test.sql
            stdin, stdout, stderr = self.ssh.exec_command(
                "cat {dumpfile} | mysql --user=debian-sys-maint "
                "--password={password}".format(password=maintainer_password2,
                                               dumpfile=dumpfile.name))
            err = stderr.read()
            if err:
                self.add_info("ERROR: {0}".format(err))
            else:
                self.add_info("Dumped SQL database on remote server")
            # delete remote file
            self.ssh.exec_command(
                "rm -f {dumpfile}".format(dumpfile=dumpfile.name))
        else:
            self.add_info("ERROR: {0}".format(err))

        #
        # Get the position on server1
        #
        p = Popen(['mysql', '--user=debian-sys-maint',
                   '--password={0}'.format(maintainer_password)],
                  stdin=PIPE,
                  stdout=PIPE,
                  stderr=PIPE)
        output, err = p.communicate(input="show master status;")
        r = p.returncode
        if r == 0:
            self.add_info(output)
            for line in output.split("\n"):
                elems = line.split()
                if len(elems) > 2 and elems[2] == "pi":
                    self.file_local = elems[0]
                    self.position_local = elems[1]
                    self.add_info("Local File:     {0}".format(self.file_local))
                    self.add_info("Local Position: {0}".format(
                        self.position_local))
        else:
            self.add_info("====== ERROR =======")
            self.add_info(err)

        self.add_info("Configuring MySQL on remote server...")
        # clean up the old database
        stdin, stdout, stderr = self.ssh.exec_command(
            "echo 'show master status;' "
            "| mysql --user=debian-sys-maint "
            "--password={0}".format(maintainer_password2))
        output = stdout.read()
        self.add_info(output)
        err = stderr.read()
        if err:
            self.add_info("======== ERROR ========")
            self.add_info(err)
        for line in output.split("\n"):
            elems = line.split()
            if len(elems) > 2 and elems[2] == "pi":
                self.file_remote = elems[0]
                self.position_remote = elems[1]
                self.add_info("Remote File:     {0}".format(self.file_remote))
                self.add_info("Remote Position: {0}".format(
                    self.position_remote))

        self.add_info("Drop replication user on remote machine...")
        # Drop user
        stdin, stdout, stderr = self.ssh.exec_command(
            "echo \"drop user 'replicator'@'%';\""
            "| mysql --user=debian-sys-maint "
            "--password={0}".format(maintainer_password2))
        err = stderr.read()
        if err:
            self.add_info("ERROR: {0}".format(err))
            self.add_info("       This maybe due to the fact, that the user "
                          "did not exist, yet.")

        # create everything remote
        self.add_info("Add replication on remote server...")
        stdin, stdout, stderr = self.ssh.exec_command(
        """echo \"create user 'replicator'@'%' identified by '{replicator_password}';
grant replication slave on *.* to 'replicator'@'%';
slave stop;
CHANGE MASTER TO MASTER_HOST = '{local_ip}', MASTER_USER = 'replicator', MASTER_PASSWORD = '{replicator_password}', MASTER_LOG_FILE = '{local_file}', MASTER_LOG_POS = {local_position};
slave start;\" | mysql --user=debian-sys-maint --password={maintainer_pw}
""".format(replicator_password=replicator_password,
           local_file=self.file_local,
           local_position=self.position_local,
           local_ip=self.local_ip,
           maintainer_pw=maintainer_password2)
        )
        err = stderr.read()
        if err:
            self.add_info("ERROR: {0}".format(err))
        #
        #  Configure replication on LOCAL host
        #
        self.add_info("Add replication user on local server...")
        p = Popen(['mysql', '--user=debian-sys-maint',
                   '--password={0}'.format(maintainer_password)],
                  stdin=PIPE, stdout=PIPE, stderr=PIPE)

        p.communicate("drop user 'replicator'@'%';")

        p = Popen(['mysql', '--user=debian-sys-maint',
                   '--password={0}'.format(maintainer_password)],
                  stdin=PIPE, stdout=PIPE, stderr=PIPE)
        output, err = p.communicate(
            input="""
create user 'replicator'@'%' identified by '{replicator_password}';
grant replication slave on *.* to 'replicator'@'%';
slave stop;
CHANGE MASTER TO MASTER_HOST = '{remote_ip}', MASTER_USER = 'replicator',
    MASTER_PASSWORD = '{replicator_password}', MASTER_LOG_FILE =
    '{remote_file}', MASTER_LOG_POS = {remote_position};
slave start;
""".format(replicator_password=replicator_password, remote_ip=self.remote_ip,
           remote_file=self.file_remote, remote_position=self.position_remote))
        if p.returncode:
            self.add_info("ERROR: {0!s}".format(err))

        self.add_info("Starting local webserver")
        self.os.restart(service="apache2", action="start")
        self.add_info("Starting remote webserver")
        self.ssh.exec_command("service apache2 start")
        self.add_info("\nRedundant setup complete.")

        self.d.scrollbox(self.info, height=20, width=60)



class DBMenu(object):

    def __init__(self, app, dialog, pConfig):
        self.app = app
        self.d = dialog
        self.pConfig = pConfig
        self.db = MySQLConfig()
        self.peer = Peer(self.d, self.pConfig, self.db)

    def menu(self):
        bt = "Configure the database connection"
        while 1:
            current_config = self.pConfig.get_DB()
            code, tags = self.d.menu(
                "The current database configuration string is %s" % current_config,
                choices=[("init tables", "create missing tables"),
                         ("view redundancy", ""),
                         ("setup redundancy", "master master replication"),
                         ("stop redundancy", "revert to single database")],

                backtitle=bt)
            if code == self.d.DIALOG_OK:
                if tags.startswith("init"):
                    self.db_init()
                elif tags.startswith("view"):
                    self.redundancy_status()
                elif tags.startswith("stop redundancy"):
                    code = self.d.yesno(
                        "Do you really want to stop the redundancy? This "
                        "server will be reverted to a single master. The "
                        "other master will not be touched. You can simply "
                        "shut down the other machine.", width=60, height=10
                    )
                    if code == self.d.DIALOG_OK:
                        self.peer.stop_redundancy()
                elif tags.startswith("setup"):
                    if self.peer.get_peer_data():
                        # Now we need to check, if the remote machine is
                        # running privacyIDEA and MySQL.
                        try:
                            self.peer.ssh.set_missing_host_key_policy(
                                AutoAddPolicy())
                            self.peer.ssh.connect(str(self.peer.remote_ip),
                                               username="root",
                                               password=self.peer.password)
                            stdin, stdout, stderr = self.peer.ssh.exec_command(
                                'dpkg -l privacyidea-apache2')
                            output_pi = stdout.read()
                            error_pi = stderr.read()

                            stdin, stdout, stderr = self.peer.ssh.exec_command(
                                'dpkg -l mysql-server')
                            output_mysql = stdout.read()
                            error_mysql = stderr.read()
                            self.peer.ssh.close()
                            if not output_mysql:
                                self.d.msgbox(
                                    "MySQL server not installed on {0!s}. "
                                    "Please install mysql-server.".format(
                                    self.peer.remote_ip))
                                break
                            if not output_pi:
                                self.d.msgbox(
                                    "privacyIDEA not installed on "
                                    "{0!s}. Please install "
                                    "privacyidea-apache2.".format(
                                    self.peer.remote_ip))
                                break
                        except SSHException as exx:
                            self.d.msgbox("{0!s}".format(exx))
                            break

                        code = self.d.yesno(
                            "OK. privacyIDEA and MySQL is installed on the "
                            "remote server. We are ready to setup redundancy. "
                            "Data will be cloned to the remote server. All "
                            "privacyIDEA data on the remote server will be "
                            "lost. Shall we proceed?", width=60)
                        if code != self.d.DIALOG_OK:
                            break
                        else:
                            self.peer.setup_redundancy()

            else:
                break

    def redundancy_status(self):
        r, bind, server_id = self.db.is_redundant()
        self.d.scrollbox(
"""
Master-Master replication active: {active!s}
Server ID: {server_id!s}
Bind Address: {bind_address!s}
""".format(active=r, bind_address=bind, server_id=server_id),
            width=60, height=20)

    def db_init(self):
        db_connect = self.pConfig.get_DB()
        code = self.d.yesno("Do you want to recreate the tables? "
                            "Existing data will not be lost. Only new tables "
                            "in the database scheme will be created on %s" %
                            db_connect,
                            width=70,
                            backtitle="Create database tables")
        if code == self.d.DIALOG_OK:
            r = self.pConfig.DB_init()
            if r:
                self.d.msgbox("Created database tables.")
            else:
                self.d.scrollbox("Error creating database tables.")



class BackupMenu(object):

    def __init__(self, app, dialog):

        self.app = app
        self.d = dialog
        self.Backup = Backup()

    def menu(self):
        bt = "Backup and Restore configuration"
        while 1:
            code, tags = self.d.menu("Backup and Restore",
                                     choices=[("Configure backup", ""),
                                              ("Backup now", ""),
                                              ("View Backups", "")],
                                     backtitle=bt)
            if code == self.d.DIALOG_OK:
                if tags.startswith("Configure"):
                    self.config()
                elif tags.startswith("Backup"):
                    self.now()
                elif tags.startswith("View Backup"):
                    self.view()
            else:
                break

    def config(self):
        '''
        Display the cronjobs of user privacyidea
        '''
        bt = "Define backup times"
        while 1:
            cronjobs = self.Backup.get_cronjobs()
            choices = [("Add new backup date", "")]
            for cronjob in cronjobs:
                if cronjob.user == "privacyidea":
                    comment = "backup job."
                    if cronjob.minute != "*":
                        comment = "hourly backup job."
                    if cronjob.hour != "*":
                        comment = "daily backup job."
                    if cronjob.dow != "*":
                        comment = "weekly backup job."
                    if cronjob.dom != "*":
                        comment = "monthly backup job."
                    if cronjob.month != "*":
                        comment = "yearly backup job."
                    choices.append(("%s %s %s %s %s" % (cronjob.minute,
                                                        cronjob.hour,
                                                        cronjob.dom,
                                                        cronjob.month,
                                                        cronjob.dow),
                                   comment))
            code, tags = self.d.menu("Here you can define times, when "
                                     "to run a backup.",
                                     choices=choices,
                                     backtitle=bt)

            if code == self.d.DIALOG_OK:
                if tags.startswith("Add"):
                    self.add()
                else:
                    self.delete(tags)
            else:
                break
        pass

    def add(self):
        '''
        Add a backup date.
        '''
        bt = "Add a new backup date"
        code, bdate = self.d.inputbox("The date to run the backup. "
                                      "Please enter it like this: "
                                      "<Minute>  <Hour>  <Day-of-Month> "
                                      " <Month>  <Day-of-Week>. You may"
                                      " use '*' as wildcard entry.",
                                      width=70,
                                      backtitle=bt)

        if code == self.d.DIALOG_OK:
            date_fragments = bdate.split()
            if len(date_fragments) == 5:
                pass
            elif len(date_fragments) == 4:
                date_fragments.append('*')
            elif len(date_fragments) == 3:
                date_fragments.append('*')
                date_fragments.append('*')
            elif len(date_fragments) == 2:
                date_fragments.append('*')
                date_fragments.append('*')
                date_fragments.append('*')
            elif len(date_fragments) == 1:
                date_fragments.append('*')
                date_fragments.append('*')
                date_fragments.append('*')
                date_fragments.append('*')
            else:
                return
            self.Backup.add_backup_time(date_fragments)

    def delete(self, tag):
        '''
        Delete a backup date
        '''
        bt = "Delete a backup date"
        (minute, hour, dom, month, dow) = tag.split()
        code = self.d.yesno("Do you want to delete the backup "
                            "job at time %s:%s. "
                            "Month:%s, Day of Month: %s, "
                            "Day of week: %s?" %
                            (hour, minute, month, dom, dow))
        if code == self.d.DIALOG_OK:
            # Delete backup job.
            self.Backup.del_backup_time(hour, minute, month, dom, dow)

    def restore(self, tag):
        '''
        Restore a backup
        '''
        bt = "Restore a backup"
        code = self.d.yesno("Are you sure you want to restore the backup %s? "
                            "Current data will be lost. The restore will "
                            "restore the encryption key, administrator "
                            "settings, token database, audit log, RADIUS "
                            "clients, server certificates... "
                            "If unsure, please "
                            "perform a backup before restoring the old one."
                            % tag,
                            width=70)
        if code == self.d.DIALOG_OK:
            # Restore the backup
            self.d.gauge_start("Restoring backup %s" % tag, percent=20)
            self.Backup.restore_backup(tag)
            self.d.gauge_update(percent=90)
            self.data_changed = True
            time.sleep(1)
            self.d.gauge_stop()

    def now(self):
        '''
        Run the backup now.
        '''
        self.Backup.backup_now()

    def view(self):
        '''
        View the saved backup files to restore one.
        '''
        bt = "Restore a backup"
        while 1:
            backups = self.Backup.get_backups()
            choices = []
            for bfile in sorted(backups.keys(), reverse=True):
                choices.append((bfile, "%s %s" % (backups[bfile].get("size"),
                                                  backups[bfile].get("time"))))
            if len(choices) == 0:
                    self.d.msgbox("No backups found!")
                    break
            else:
                code, tags = self.d.menu("Choose a backup you wish to "
                                         "restore...",
                                         choices=choices,
                                         backtitle=bt,
                                         width=78)
                if code == self.d.DIALOG_OK:
                    self.restore(tags)
                else:
                    break



class RadiusMenu(object):

    def __init__(self, app, dialog):
        self.app = app
        self.d = dialog
        try:
            self.RadiusConfig = FreeRADIUSConfig()
        except:
            # No Radius Server available
            self.RadiusConfig = None

    def menu(self):
        while 1:
            code, tags = self.d.menu("Configure FreeRADIUS",
                                     choices=[("client config", ""),
                                              ("sites",
                                               "Enable and disable RADIUS "
                                               "sites")
                                              ])
            if code == self.d.DIALOG_OK:
                if tags.startswith("client"):
                    self.clients()
                if tags.startswith("sites"):
                    self.sites()
            else:
                break

    def sites(self):
        sites = self.RadiusConfig.get_sites()
        code, tags = self.d.checklist("The FreeRADIUS sites you want to "
                                      "enable. You should only enable "
                                      "'privacyidea' unless you know "
                                      "exactly what you are doing!",
                                      choices=sites,
                                      backtitle="Enable sites")
        if code == self.d.DIALOG_OK:
            self.RadiusConfig.enable_sites(tags)

    def clients(self):
        while 1:
            clients = [("Add new client", "Add a new RADIUS client")]
            clients_from_file = self.RadiusConfig.clients_get()
            for client, v in clients_from_file.items():
                clients.append((client, "%s/%s (%s)" % (v.get("ipaddr"),
                                                        v.get("netmask"),
                                                        v.get("shortname"))))
            code, tags = self.d.menu("You can select an existing RADIUS client "
                                     "to either delete it or change it "
                                     "or create a new client",
                                     choices=clients,
                                     backtitle="Manage RADIUS clients")

            if code == self.d.DIALOG_OK:
                if tags.startswith("Add new"):
                    self.add()
                else:
                    self.manage(tags)
            else:
                break

    def add(self):
        bt = "Add a new RADIUS client"
        code, clientname = self.d.inputbox("The name of the new client",
                                           backtitle=bt)
        if code != self.d.DIALOG_OK:
            return
        code, ip = self.d.inputbox("The IP address of the new client %s" %
                                   clientname,
                                   backtitle=bt)
        if code != self.d.DIALOG_OK:
            return

        code, netmask = self.d.radiolist("The netmask of the new client %s.",
                                         choices=[("32", "255.255.255.255 ("
                                                         "single Host)", 0),
                                                  ("24", "255.255.255.0", 1),
                                                  ("16", "255.255.0.0", 0),
                                                  ("8", "255.0.0.0", 0),
                                                  ("0", "0.0.0.0 ("
                                                        "everything)", 0),
                                                  ("1", "128.0.0.0", 0),
                                                  ("2", "192.0.0.0", 0),
                                                  ("3", "224.0.0.0", 0),
                                                  ("4", "240.0.0.0", 0),
                                                  ("5", "248.0.0.0", 0),
                                                  ("6", "252.0.0.0", 0),
                                                  ("7", "254.0.0.0", 0),
                                                  ("9", "255.128.0.0", 0),
                                                  ("10", "255.192.0.0", 0),
                                                  ("11", "255.224.0.0", 0),
                                                  ("12", "255.240.0.0", 0),
                                                  ("13", "255.248.0.0", 0),
                                                  ("14", "255.252.0.0", 0),
                                                  ("15", "255.254.0.0", 0),
                                                  ("17", "255.255.128.0", 0),
                                                  ("18", "255.255.192.0", 0),
                                                  ("19", "255.255.224.0", 0),
                                                  ("20", "255.255.240.0", 0),
                                                  ("21", "255.255.248.0", 0),
                                                  ("22", "255.255.252.0", 0),
                                                  ("23", "255.255.254.0", 0),
                                                  ("25", "255.255.255.128", 0),
                                                  ("26", "255.255.255.192", 0),
                                                  ("27", "255.255.255.224", 0),
                                                  ("28", "255.255.255.240", 0),
                                                  ("29", "255.255.255.248", 0),
                                                  ("30", "255.255.255.252", 0),
                                                  ("31", "255.255.255.254", 0)
                                                  ],
                                         backtitle=bt)
        if code != self.d.DIALOG_OK:
            return

        code, secret = self.d.inputbox("The secret of the new client %s" %
                                       clientname,
                                       backtitle=bt)

        code, shortname = self.d.inputbox("The shortname of the new client %s" %
                                          clientname,
                                          backtitle=bt)

        if code == self.d.DIALOG_OK:
            client = {}
            if ip:
                client["ipaddr"] = ip
            if netmask:
                client["netmask"] = netmask
            if secret:
                client["secret"] = secret
            if shortname:
                client["shortname"] = shortname
            self.RadiusConfig.client_add({clientname: client})

    def manage(self, clientname):
        bt = "Manage client %s" % clientname
        code, tags = self.d.menu("Manage client %s." % clientname,
                                 choices=[("Delete client", "")],
                                 backtitle=bt)
        if code == self.d.DIALOG_OK:
            if tags.startswith("Delete"):
                self.d.yesno("Do you really want to delete the "
                             "RADIUS client %s?" % clientname)
                self.RadiusConfig.client_delete(clientname)


class MainMenu(object):
    
    def __init__(self, config=None):
        self.data_changed = False
        if config:
            self.config_file = config
        else:
            self.config_file = DEFAULT_CONFIG

        try:
            self.pConfig = PrivacyIDEAConfig(self.config_file)
        except IOError:
            sys.stderr.write("="*75)
            sys.stderr.write("\nCan not access {0!s}. You need to have read "
                             "and write access to this "
                             "file.\n".format(self.config_file))
            sys.exit(5)

        self.app = create_app(config_name="production")
        self.d = Dialog(dialog="dialog")
        self.radiusDialog = RadiusMenu(self.app, self.d)
        self.backupDialog = BackupMenu(self.app, self.d)
        self.dbDialog = DBMenu(self.app, self.d, self.pConfig)
        self.webserverDialog = WebserverMenu(self.app, self.d)
        self.osDialog = OSMenu(self.app, self.d)

    def main_menu(self):
        choices = [("privacyIDEA", "",
                    "Configure privacyIDEA application "
                    "stuff like administrators.")
                   ]
        if self.radiusDialog.RadiusConfig:
            choices.append(("FreeRADIUS", "",
                            "Configure RADIUS settings like "
                            "the RADIUS clients."))
        choices.append(("Database", "",
                        "Configure database and setup redundancy"))
        choices.append(("Webserver", "",
                        "Restart Webserver and manage certificate."))
        choices.append(("Backup and Restore", "",
                        "Backup or Restore of privacyIDEA"
                        "configuration and database and"
                        "RADIUS clients."))
        choices.append(("Operating System", "",
                        "Configure SSH and Login settings for the OS."))
        while 1:
            code, tags = self.d.menu("Which subject do you want to configure?",
                                     choices=choices,
                                     backtitle="privacyIDEA configuration",
                                     cancel="Exit",
                                     item_help=1)
            if code == self.d.DIALOG_OK:
                print tags
                if tags == "privacyIDEA":
                    self.privacyidea_menu()
                elif tags == "FreeRADIUS":
                    self.radiusDialog.menu()
                elif tags.startswith("Backup"):
                    self.backupDialog.menu()
                elif tags.startswith("Webserver"):
                    self.webserverDialog.menu()
                elif tags.startswith("Operating"):
                    self.osDialog.menu()
                elif tags.startswith("Database"):
                    self.dbDialog.menu()
                    
            else:
                # End
                if self.data_changed:
                    self.webserverDialog.restart()
                break
    
    def privacyidea_menu(self):
        while 1:
            code, tags = self.d.menu(
                "Configure privacyidea",
                choices=[("view config", "Display configuration.",""),
                         ("loglevel", "Change log level.", ""),
                         ("admin realms", "Modify admin realms.", ""),
                         ("manage local admins", "Modify admins.", ""),
                         ("Danger zone!", "Enter at your own risk!",
                                          "Here you may recreated your "
                                          "encryption and signing keys.")],
                menu_height=22,
                backtitle="privacyIDEA configuration",
                item_help=1)
        
            if code == self.d.DIALOG_OK:
                if tags.startswith("loglevel"):
                    self.privacyidea_loglevel()
                elif tags.startswith("view"):
                    self.privacyidea_view()
                elif tags.startswith("admin realms"):
                    self.privacyidea_adminrealms()
                elif tags.startswith("manage local admins"):
                    self.privacyidea_admins()
                elif tags.startswith("Danger zone"):
                    self.privacyidea_danger_menu()
            else:
                break

    def privacyidea_danger_menu(self):
        while 1:
            code, tags = self.d.menu(
                "privacyIDEA Danger Zone",
                choices=[("initialize pi.cfg-file",
                          "Create new pi.cfg-file.",
                          "This will also create new salt and pepper. Admins "
                          "will not be able to login anymore!"),
                         ("encryption key", "Create new encryption key.",
                          "Token seeds can not be decrypted anymore!"),
                         ("signing key", "Create new audit signing key.",
                          "Old audit entries can not be verified anymore.")],
                menu_height=22,
                backtitle="privacyIDEA Danger Zone",
                item_help=1)

            if code == self.d.DIALOG_OK:
                if tags.startswith("initialize"):
                    self.privacyidea_initialize()
                elif tags.startswith("encryption"):
                    self.privacyidea_enckey()
                elif tags.startswith("signing"):
                    self.privacyidea_sign()
            else:
                break


    def privacyidea_admins(self):
        while 1:
            with self.app.app_context():
                db_admins = get_db_admins()
            admins = [("Add new admin", "Add a new administrator")]
            for admin in db_admins:
                admins.append((admin.username, admin.email or ""))
            code, tags = self.d.menu("You can select an existing administrator "
                                     "to either delete it or change the " 
                                     "password or create a new admin",
                                     choices=admins,
                                     backtitle="Manage administrators")
            
            if code == self.d.DIALOG_OK:
                if tags == "Add new admin":
                    self.privacyidea_admin_add()
                else:
                    self.privacyidea_admin_manage(tags)
            else:
                break
            
    def privacyidea_admin_manage(self, admin_name):
        bt = "Manage administrator"
        # TODO: We might also want to change the email of the admin
        code, tags = self.d.menu("Manage admin %s" % admin_name,
                                 choices=[("Delete admin", ""),
                                          ("Change password", "")],
                                 backtitle=bt)
        if code == self.d.DIALOG_OK:
            if tags.startswith("Delete"):
                self.d.yesno("Do you really want to delete the "
                             "administrator %s?" % admin_name)
                with self.app.app_context():
                    delete_db_admin(admin_name)

            if tags.startswith("Change password"):
                password = self.privacyidea_admin_password(admin_name)
                pass

    def privacyidea_admin_password(self, admin_name, create=False):
        bt = "Setting password for administrator %s" % admin_name
        password = None
        while 1:
            code, password1 = self.d.passwordbox("Enter the password for the "
                                                 "administrator %s.\n"
                                                 "(Your typing will not be "
                                                 "visible)" %
                                                 admin_name,
                                                 backtitle=bt)
                
            if code == self.d.DIALOG_OK:
                code, password2 = self.d.passwordbox("Repeat the password",
                                                     backtitle=bt)
                if code == self.d.DIALOG_OK:
                    if password1 != password2:
                        self.d.msgbox("The passwords do not match. "
                                      "Please try again.")
                    else:
                        password = password1
                        with self.app.app_context():
                            create_db_admin(self.app, admin_name,
                                            password=password)
                        break
                else:
                    break
            else:
                break
        return password 
            
    def privacyidea_admin_add(self):
        bt = "Add a new administrator"
        code, admin_name = self.d.inputbox("The username of the new "
                                     "administrator",
                                     backtitle=bt)
        
        if code == self.d.DIALOG_OK:
            password = self.privacyidea_admin_password(admin_name,
                                                       create=True)

    def privacyidea_adminrealms(self):
        adminrealms = self.pConfig.get_superusers()
        # convert to string
        adminrealms = ",".join(adminrealms)
        code, tags = self.d.inputbox("You may enter a comma seperated list "
                                     "of realms that are recognized as "
                                     "admin realms.",
                                     init=adminrealms,
                                     width=40,
                                     backtitle="configure admin realms")
        if code == self.d.DIALOG_OK:
            # convert to list with no whitespaces in elemtents
            adminrealms = [x.strip() for x in tags.split(",")]
            self.pConfig.set_superusers(adminrealms)
            self.pConfig.save()
            self.data_changed = True
         
    def privacyidea_initialize(self):
        code = self.d.yesno("Do you want to initialize "
                            "the config file? Old privacyIDEA "
                            "configurations will be overwritten!",
                            backtitle="Initialize privacyIDEA configuration",
                            defaultno=1)
        if code == self.d.DIALOG_OK:
            self.pConfig.initialize()
            self.pConfig.save()
            self.data_changed = True
            
    def privacyidea_enckey(self):
        code = self.d.yesno("Do you want to create a new encryption key? "
                            "All token keys will not be readable anymore!",
                            backtitle="Create a new encryption key.",
                            defaultno=1)
        if code == self.d.DIALOG_OK:
            r, f = self.pConfig.create_encryption_key()
            if r:
                self.d.msgbox("Successfully created new encryption key %s." %
                              f)
            else:
                self.d.msgbox("Failed to create new encryption key %s!" %
                              f)
            
    def privacyidea_sign(self):
        code = self.d.yesno("Do you want to create a new audit trail "
                            "signing key? "
                            "Older audit entries can not be verified anymore.",
                            backtitle="Create a new signing key.",
                            defaultno=1)
        if code == self.d.DIALOG_OK:
            r, f = self.pConfig.create_audit_keys()
            if r:
                self.d.msgbox("Successfully created new audit keys %s." %
                              f)
            else:
                self.d.msgbox("Failed to create new audit keys %s!" % f)
        
    def privacyidea_loglevel(self):
        loglevel = self.pConfig.get_loglevel()
        code, tags = self.d.radiolist(
            "choose a loglevel",
            choices=[("logging.DEBUG", "Excessive logging.",
                      int(loglevel == "logging.DEBUG")),
                     ("logging.INFO", "Normal logging.",
                      int(loglevel == "logging.INFO")),
                     ("logging.WARN", "Only log warnings.",
                      int(loglevel == "logging.WARN")),
                     ("logging.ERROR", "Sparse logging.",
                      int(loglevel == "logging.ERROR"))],
            backtitle="privacyIDEA loglevel.")
        if code == self.d.DIALOG_OK:
            self.pConfig.set_loglevel(tags)
            self.pConfig.save()
            self.data_changed = True

    def privacyidea_view(self):
        text = """
    The secret key file             : %s
    List of the admin realms        : %s
    Loglevel                        : %s
    """ % (self.pConfig.get_keyfile(),
           self.pConfig.get_superusers(),
           self.pConfig.get_loglevel())
        self.d.scrollbox(text)
    


def create_arguments():
    parser = argparse.ArgumentParser(description=DESCRIPTION,
                                     fromfile_prefix_chars='@')
    parser.add_argument("-f", "--file",
                        help="The pi.cfg file.",
                        required=False)
    parser.add_argument("-v", "--version",
                        help="Print the version of the program.",
                        action='version', version='%(prog)s ' + VERSION)
       
    args = parser.parse_args()
    return args



def main():
    locale.setlocale(locale.LC_ALL, '')
    args = create_arguments()
    pS = MainMenu(config=args.file)
    pS.main_menu()
    

if __name__ == '__main__':
    main()



